# -*- coding: utf-8 -*-
"""
==========================
Generic Arduino Controller
==========================

This is a generic controller for Arduino (type) devices.
It includes serial write and query methods.
Higher level stuff could (should?) be done at Instrument level.
Extra methods could however also be added to this controller,
as long as they don't break the existing functionality.

This controller is however intended to be agnostic of what code/firmware/sketch
is running on the Arduino. I suggest to keep it that way and put device
specific functionality in a dedicated instrument.
This also means Dummy mode needs to be implemented mostly at Instrument level.

"""
import serial
import serial.tools.list_ports
import time
import logging
from hyperion.controller.base_controller import BaseController

class GenericArduinoController(BaseController):
    """ Generic Arduino Controller """


    def __init__(self, settings = {'port':'COM4', 'dummy': False, 'baudrate': 9600, 'write_termination': '\n', 'read_timeout':1.0}):
        """ Init of the class.

        :param settings: this includes all the settings needed to connect to the device in question.
        :type settings: dict

        """
        super().__init__(settings)  # mandatory line
        self.logger = logging.getLogger(__name__)
        self.rsc = None
        self.logger.debug('Generic Arduino Controller created.')
        self.name = 'Generic Arduino Controller'

        if 'dummy' in settings:
            self.dummy = settings['dummy']
        else:
            self.dummy = False
            
        if 'port' in settings:
            self._port = settings['port']
        else:
            self._port = None
        
        if 'baudrate' in settings:
            self._baud = settings['baudrate']
        else:
            self._baud = 9600
            
        if 'write_termination' in settings:
            self._write_termination = settings['write_termination']
        else:
            self._write_termination = ''
            
        if 'read_termination' in settings:
            self._read_termination = settings['read_termination']
        else:
            self._read_termination = ''

        if 'write_timeout' in settings:
            self._write_timeout = settings['write_timeout']
        else:
            self._write_timeout = 0.1
            
        if 'read_timeout' in settings:
            self._read_timeout = settings['read_timeout']
        else:
            self._read_timeout = 0.1
            
        if 'encoding' in settings:
            self._encoding = settings['encoding']
        else:
            self._encoding = 'ascii'
            
            
            
        

    def initialize(self):
        """ Starts the connection to the device in port """
        self.rsc = serial.Serial(port=self._port,
                                     baudrate=self._baud,
                                     timeout=self._read_timeout,
                                     write_timeout=self._write_timeout)
        self.logger.debug('Initialized Arduino connection on port {}.'.format(self._port))
        self._is_initialized = True     # THIS IS MANDATORY!!
                                        # this is to prevent you to close the device connection if you
                                        # have not initialized it inside a with statement


    def finalize(self):
        """ This method closes the connection to the device.
        It is ran automatically if you use a with block
        """
        
        if self._is_initialized:
            if self.rsc is not None:
                self.rsc.close()
                self.logger.debug('The connection to the Arduino is closed.')
        else:
            self.logger.warning('Finalizing before initializing connection to the Arduino')

        self._is_initialized = False
        

    def idn(self):
        """ Identify command

        :return: identification for the device
        :rtype: string
        """
        self.logger.debug('Ask IDN to device.')
        return self.query('*IDN?')

    def write(self, message):
        """ Sends the message to the Arduino.

        :param message: the message to write into the Ardfuino serial buffer
        :type message: string

        """
        if not self._is_initialized:
            raise Warning('Trying to write to device before initializing')

        message += self._write_termination
        self.logger.debug('Sending to Arduino: {}'.format(message))
        self.rsc.write( message.encode(self._encoding) )



    def read_serial_buffer_in(self, wait_for_termination_char = True):
        """
        Reads everyting the Arduino has sent. By default it waits untill a line 
        is terminated by a termination character (\n or \r), but that check can
        be disabled using the input parameter.

        :param untill_at_least_one_termination_char: defaults to True
        :type untill_at_least_one_termination_char: bool 
        :return: complete serial buffer from the Arduino
        :rtype: bytes

        """
        if not self._is_initialized:
            raise Warning('Trying to read from Arduino before initializing')


        # complete alternative approach:
        
        
        # At least for Arduino, it appears the buffer is filled in chuncks of max 32 bytes
        byte_time = 1/self.rsc.baudrate * (self.rsc.bytesize + self.rsc.stopbits + (self.rsc.parity != 'N'))
        raw = b''
        in_buffer = 0
        new_in_buffer = 0
        term_chars = '\n\r'.encode(self._encoding)
        ends_at_term_char = False
        #start_time = time.time() + 0.0001
        # Keep checking 
        expire_time = time.time() +  self._read_timeout + .0000000001
        while (not ends_at_term_char) and (time.time() < expire_time):
            time.sleep(byte_time*20)
            new_in_buffer = self.rsc.in_waiting
            if new_in_buffer > in_buffer:
                # if the buffer has grown make sure the expire_time is at least long enough to read in another 32 bytes
                expire_time = max(expire_time, time.time()+byte_time*32)
                in_buffer = new_in_buffer
            
            raw += self.rsc.read( self.rsc.in_waiting )
            if not wait_for_termination_char or (len(raw) and (raw[-1] in term_chars)):
                ends_at_term_char = True
        
#        while not ends_at_term_char:
#            # Keep checking if new bytes arrive in buffer (if it stays empty, wait at least for self._read_timeout)
#            in_buffer_prev = in_buffer-1
#            while in_buffer > in_buffer_prev or (in_buffer==0 and (time.time() - start_time <= self._read_timeout)):
#                in_buffer_prev = in_buffer
#                time.sleep(wait_time)      
#                in_buffer = self.rsc.in_waiting
#                print((in_buffer,in_buffer_prev))
#            
#            raw = self.rsc.read( self.rsc.in_waiting )
#            if wait_for_termination_char or (len(raw) and raw[-1] in term_chars):
#                ends_at_term_char = True
            
        self.logger.debug('{} bytes received'.format(len(raw)))
        return raw
    
#        self.rsc.stopbits
#        term_chars = '\n\r'.encode(self._encoding)
#        
#        raw = b''
#        last_line_is_not_terminated = True
#        start_time = time.time() + 0.0001
#        while last_line_is_not_terminated and (time.time() - start_time <= self._read_timeout):
#            raw += self.rsc.read( self.rsc.in_waiting )
#            if not wait_for_termination_char:
#                last_line_is_not_terminated = False
#            elif len(raw):
#                if raw[-1] in term_chars:
#                    last_line_is_not_terminated = True
#                else:
#                    last_line_is_not_terminated = False
#                
#            #if len(raw) and (raw[-1]=='\n'.encode(self._encoding) or raw[-1]=='\r'.encode(self._encoding)):
#            #    last_line_is_not_terminated = False
#            #elif ('\n'.encode(self._encoding) in raw) or ('\r'.encode(self._encoding) in raw):
#            #    last_line_is_not_terminated = False
            

        return raw
       
    def read_lines(self, remove_leading_trailing_empty_line=True):
        """
        Reads all lines the Arduino has sent and returns list of strings.
        It interprets both \r \n and combinations as a newline character.

        :param remove_leading_trailing_empty_line: defaults to True
        :type remove_leading_trailing_empty_line: bool
        :return: list of lines received from the Arduino
        :rtype: list of strings
        """
        
        response = str(self.read_serial_buffer_in(), encoding=self._encoding)
        response = response.replace('\n\r','\n')
        response = response.replace('\r\n','\n')
        response = response.replace('\r','\n')
        response_list = response.split('\n')
        if remove_leading_trailing_empty_line:
            if len(response_list) and response_list[-1]=='':
                del response_list[-1]
            if len(response_list) and response_list[0]=='':
                del response_list[0]
            
        return response_list
    
    def query(self, message):
        """
        Writes message in the Arduino Serial buffer and Reads the response.
        Note, it clears the input buffer before sending out the query.

        :param message: command to send to the Arduino
        :type message: str
        :return: response from the Arduino
        :rtype: str
        """
        
        if not self._is_initialized:
            raise Warning('Trying to query from Arduino before initializing.')

        self.rsc.reset_output_buffer()
        self.rsc.reset_input_buffer()
        self.write(message)
        self.logger.debug('Sent message: {}.'.format(message))
        ans = self.read_lines()
        self.logger.debug('Received message: {}.'.format(ans))
        return ans
    


class GenericArduinoControllerDummy(GenericArduinoController):
    """
    Arduino Controller Dummy
    ========================

    A dummy version of the Generic Arduino Controller.

    In essence we have the same methods and we re-write the query to answer something meaningful but
    without connecting to the real device.

    """


    def query(self, msg):
        """ writes into the device msg

        :param msg: command to write into the device port
        :type msg: string
        """
        self.logger.debug('Writing into the dummy device:{}'.format(msg))
        ans = 'A general dummy answer'
        return ans



if __name__ == "__main__":
    from hyperion import _logger_format, _logger_settings
    logging.basicConfig(level=logging.ERROR, format=_logger_format,
                        handlers=[
                            logging.handlers.RotatingFileHandler(_logger_settings['filename'],
                                                                 maxBytes=_logger_settings['maxBytes'],
                                                                 backupCount=_logger_settings['backupCount']),
                            logging.StreamHandler()])

    dummy = False  # change this to false to work with the real device in the COM specified below.

    if dummy:
        my_class = GenericArduinoControllerDummy
    else:
        my_class = GenericArduinoController

    with my_class(settings = {'port':'COM4', 'write_termination':'\n'}) as dev:
        dev.initialize()
        time.sleep(3)
        print('start')
        print('after start up: {}'.format(dev.read_lines()))
        print('ch1: {}'.format(dev.query('1?')))
        print('ch2: {}'.format(dev.query('2?')))        
        print('idn: {}'.format(dev.idn()))
        


